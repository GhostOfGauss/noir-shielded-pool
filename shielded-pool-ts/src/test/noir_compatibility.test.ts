import { expect } from "chai";
import { Asset } from "../asset";
import { PublicKey, SecretKey } from "../keypair";
import { PreUtxo, Utxo } from "../utxo";
import { MerkleTree } from "../merkle";
import { Transaction, TransactionPost } from "../transaction";
import { UltraHonkBackend } from "@aztec/bb.js";
import { Noir } from "@noir-lang/noir_js";
import circuit from "../../../circuit/target/shielded_pool.json";

const sampleAsset = new Asset(1, 3);

// Sample data generated by nargo, see circuit/acir/keypair_acir.txt
const senderSk = new SecretKey(BigInt(2), BigInt(0));
const senderPk = new PublicKey(
  BigInt("0x6ce1b0827aafa85ddeb49cdaa36306d19a74caa311e13d46d8bc688cdbffffe"),
  BigInt("0x1c122f81a3a14964909ede0ba2a6855fc93faf6fa1a788bf467be7e7a43f80ac"),
  false
);
const receiverSk = new SecretKey(BigInt(3), BigInt(0));
const receiverPk = new PublicKey(
  BigInt("0x2941b0928df1b9480273773b36397da3e495430a2a7a3857661bc7a446c94f4d"),
  BigInt("0x13ae7e938c892308bef0f45ee7386daa2d3b447349a7d0a11b5aa4cfbe69072c"),
  false
);

const incomingAssets = [new Asset(1, 3), new Asset(1, 7)];
const outgoingAssets = [new Asset(1, 4), new Asset(1, 6)];

const sampleRandomness = [BigInt(10), BigInt(20)];

const utxoCommitments = [
  BigInt("0x2783b1b42583d50c8790f0cc009663c8f5663c35c6bd0af694f483ea8efa4573"), // Asset(1, 3), senderPk, randomness = 10
  BigInt("0x288a83c2c52b110e3785f5f5432a0e526f9b4f025d9ea59d9ce52980df8d3883"), // Asset(1, 4), senderPk, randomness = 10
  BigInt("0x1119ec7a973793011d29dd08373624333c9c2fbb93ace50565b407443dd1f96c"), // Asset(1, 5), senderPk, randomness = 10
  BigInt("0x15b24cfbce3b86b8222034a5cc10739d30f97c6ce1fd8edaf1f57e216014bf6c"), // Asset(1, 6), senderPk, randomness = 20
  BigInt("0x5e408b891d6077f2193f47b08ce81cb83279c656a84afba118646f8ac2991fa"), // Asset(1, 7), senderPk, randomness = 10
];

const utxoAccumulator = new MerkleTree();
utxoCommitments.map((leaf) => utxoAccumulator.insert(leaf));
const utxoAccumulatorRoot = utxoAccumulator.root();

// Dunno why I was weird about the sampleRandomness
const incomingPreUtxos = incomingAssets.map(
  (asset) => new PreUtxo(asset, senderPk, sampleRandomness[0])
);
const outgoingPreUtxos = outgoingAssets.map(
  (asset, i) => new PreUtxo(asset, receiverPk, sampleRandomness[i])
);

const incomingAssetIndices = [0, 4];
const incomingUtxoInclusionWitnesses = incomingAssetIndices.map((i) =>
  utxoAccumulator.createProof(i)
);

describe("UTXO", () => {
  let utxo: Utxo;

  beforeEach(() => {
    const preUtxo = new PreUtxo(sampleAsset, senderPk, sampleRandomness[0]);
    utxo = new Utxo(preUtxo);
  });

  it(`Noir UTXO commitment compatibility`, () => {
    console.log(`Utxo commitment: 0x${utxo.commitment.toString(16)}`);
    const expectedUtxoCommitment = BigInt(
      "0x2783b1b42583d50c8790f0cc009663c8f5663c35c6bd0af694f483ea8efa4573"
    );
    expect(utxo.commitment === expectedUtxoCommitment).to.equal(true);
  });

  it(`Noir UTXO nullifier compatibility`, () => {
    let nullifier = utxo.nullify(senderSk);
    console.log(`computed nullifier: 0x${nullifier.toString(16)}`);
    const expectedUtxoNulifier = BigInt(
      "0x2ec3fae46ba68ecb1de2050a46f706b607cf5ccb309055e0b9021cb927c5b4c1"
    );
    expect(nullifier === expectedUtxoNulifier).to.equal(true);
  });
});

describe("Merkle Tree", () => {
  it("Checks inclusion proofs", () => {
    utxoCommitments.map((leaf, i) => {
      const proof = utxoAccumulator.createProof(i);
      expect(utxoAccumulator.verifyProof(proof)).to.equal(true);
      expect(proof.root).to.equal(utxoAccumulatorRoot);
      expect(proof.leaf).to.equal(leaf);
      expect(proof.leafIndex).to.equal(i);

      // console.log(`Merkle root: 0x${root.toString(16)}`);
      // console.log(`Proof indexes packed: ${proof.indexes}`);
      // console.log(`Proof indexes: ${proof.toIMTMerkleProof().pathIndices}`);
      // console.log(
      //   `Proof ${JSON.stringify(proof.toCircuitInput(), undefined, 2)}`
      // );
    });
  });
});

describe("Transaction", async () => {
  let tx: Transaction;

  beforeEach(() => {
    tx = new Transaction(
      incomingPreUtxos,
      outgoingPreUtxos,
      senderSk,
      utxoAccumulatorRoot,
      incomingUtxoInclusionWitnesses
    );
  });

  it("Forms Transaction Post", () => {
    const txPost = new TransactionPost(tx, utxoAccumulator);
    // console.log(
    //   `Transaction: ${JSON.stringify(tx.toCircuitInput(), undefined, 2)}`
    // );
    // console.log(
    //   `Transaction Post: ${JSON.stringify(txPost.toCircuitInput(), undefined, 2)}`
    // );
  });

  it("Proves transaction validity", async function () {
    this.timeout(20000);

    const txPost = new TransactionPost(tx, utxoAccumulator);

    // Type-widening bug causes tsc to misinterpret
    // AbiType { "kind": "field" } as { kind: string }
    // @ts-ignore
    const noir = new Noir(circuit);
    const backend = new UltraHonkBackend(circuit.bytecode);

    const witnessStart = performance.now();
    const { witness, returnValue } = await noir.execute({
      tx: tx.toCircuitInput(),
    });
    const witnessEnd = performance.now();
    console.log(`Witness Generation took ${witnessEnd - witnessStart}ms`);
    // console.log(
    //   `circuit returns: ${JSON.stringify(returnValue, undefined, 2)}`
    // );

    // TODO: clunky comparison
    // @ts-ignore
    expect(BigInt(returnValue.accumulator_root)).to.equal(
      txPost.accumulatorRoot
    );
    // @ts-ignore
    expect(BigInt(returnValue.incoming_nullifiers[0])).to.equal(
      txPost.incomingNullifiers[0]
    );
    // @ts-ignore
    expect(BigInt(returnValue.incoming_nullifiers[1])).to.equal(
      txPost.incomingNullifiers[1]
    );
    // @ts-ignore
    expect(BigInt(returnValue.outgoing_utxos[0].commitment)).to.equal(
      txPost.outgoingUtxos[0].commitment
    );
    // @ts-ignore
    expect(BigInt(returnValue.outgoing_utxos[1].commitment)).to.equal(
      txPost.outgoingUtxos[1].commitment
    );

    const proofStart = performance.now();
    const proof = await backend.generateProof(witness);
    const proofEnd = performance.now();
    console.log(`Proof Generation took ${proofEnd - proofStart}ms`);

    const valid = await backend.verifyProof(proof);
    if (!valid) {
      throw "Invalid proof was generated";
    }
    console.log(`Proof is valid`);

    backend.destroy();
  });
});
