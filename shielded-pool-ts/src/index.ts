import { UltraHonkBackend } from "@aztec/bb.js";
import { Noir } from "@noir-lang/noir_js";
import circuit from "../../circuit/target/shielded_pool.json";
import { Asset } from "./asset";
import { PreUtxo, Utxo } from "./utxo";
import { PublicKey, SecretKey } from "./keypair";

// Type-widening bug causes tsc to misinterpret
// AbiType { "kind": "field" } as { kind: string }
// @ts-ignore
const noir = new Noir(circuit);
const backend = new UltraHonkBackend(circuit.bytecode);

// Construct input data
const incomingAssets: Asset[] = [
  {
    id: 1,
    amount: 3,
  },
  {
    id: 1,
    amount: 7,
  },
];

const outgoingAssets: Asset[] = [
  {
    id: 1,
    amount: 2,
  },
  {
    id: 1,
    amount: 8,
  },
];

// Sample data generated by nargo, see circuit/acir/keypair_acir.txt
const incomingSk = new SecretKey(BigInt(2), BigInt(0));
const incomingPk = new PublicKey(
  BigInt("0x6ce1b0827aafa85ddeb49cdaa36306d19a74caa311e13d46d8bc688cdbffffe"),
  BigInt("0x1c122f81a3a14964909ede0ba2a6855fc93faf6fa1a788bf467be7e7a43f80ac"),
  false
);

const randomness: string = "0x2";

const incomingPreUtxos: PreUtxo[] = incomingAssets.map((asset) => {
  return {
    asset,
    pk: incomingPk,
    randomness,
  };
});

const incomingUtxos: Utxo[] = incomingPreUtxos.map((pre) => new Utxo(pre));

const circuitInputs = {
  sk: incomingSk.toCircuitInput(),
};

const expectedReturn = incomingPk;

async function main() {
  const witnessStart = performance.now();
  const { witness, returnValue } = await noir.execute(circuitInputs);
  const witnessEnd = performance.now();
  console.log(`circuit returns: ${JSON.stringify(returnValue, undefined, 2)}`);
  // console.log(`expected return: ${JSON.stringify(expectedReturn)}`);
  console.log(`Witness Generation took ${witnessEnd - witnessStart}ms`);
  // console.log(`Generated witness: ${JSON.stringify(witness, undefined, 2)}`);

  const proofStart = performance.now();
  const proof = await backend.generateProof(witness);
  const proofEnd = performance.now();
  console.log(`Proof Generation took ${proofEnd - proofStart}ms`);
  // console.log(`Generated proof: ${JSON.stringify(proof, undefined, 2)}`);

  const valid = await backend.verifyProof(proof);
  if (!valid) {
    throw "Invalid proof was generated";
  }
  console.log(`Proof is valid`);

  backend.destroy();
}

main().catch(console.error);
